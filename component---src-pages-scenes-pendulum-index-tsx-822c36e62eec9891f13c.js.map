{"version":3,"sources":["webpack:///./src/pages/scenes/pendulum/index.tsx","webpack:///./src/components/Layout/index.tsx","webpack:///./src/components/BabylonCanvas/index.tsx"],"names":["__webpack_exports__","default","react__WEBPACK_IMPORTED_MODULE_0__","createElement","_components__WEBPACK_IMPORTED_MODULE_2__","b","a","init","engine","scene","canvas","light1","sphere1","sphere2","cylinder1","cylinder2","point1","point2","camera","babylonjs__WEBPACK_IMPORTED_MODULE_1__","FreeCamera","Vector3","setTarget","Zero","attachControl","DirectionalLight","position","intensity","HemisphericLight","Mesh","CreateSphere","x","y","MeshBuilder","CreateCylinder","diameterTop","diameterBottom","height","subdivisions","addChild","AbstractMesh","ground","shadowGenerator","ShadowGenerator","useBlurExponentialShadowMap","getShadowMap","renderList","push","CreateGround","receiveShadows","gravity","physics","CannonJSPlugin","enablePhysics","physicsImpostor","PhysicsImpostor","BoxImpostor","mass","restitution","disableBidirectionalTransformation","SphereImpostor","ParticleImpostor","addJoint","PhysicsJoint","Hinge2Joint","connectedPivot","connectedAxis","collision","applyImpulse","getAbsolutePosition","runRenderLoop","render","_ref","children","Fragment","react_helmet__WEBPACK_IMPORTED_MODULE_1___default","BabylonCanvas_BabylonCanvas","t","react","createRef","state","width","onResize","_this","setCanvasSize","this","setState","props","window","innerWidth","innerHeight","componentDidUpdate","prevProps","resize","componentDidMount","_this$props","engineOptions","adaptToDeviceRatio","current","babylon","Engine","Scene","addEventListener","componentWillUnmount","removeEventListener","className","_this$state","ref","Component","c","i","d"],"mappings":"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","file":"component---src-pages-scenes-pendulum-index-tsx-822c36e62eec9891f13c.js","sourcesContent":["import * as React from 'react';\nimport * as BABYLON from 'babylonjs';\nimport {\n    Layout,\n    BabylonCanvas,\n} from '../../../components';\n\nconst PendulumPage = () => <Layout>\n    <BabylonCanvas init={(engine, scene, canvas) => {\n        { // camera\n            const camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 10, -10), scene);\n            camera.setTarget(BABYLON.Vector3.Zero());\n            camera.attachControl(canvas, true);\n        }\n        let light1: BABYLON.DirectionalLight;\n        { // light\n            light1 = new BABYLON.DirectionalLight('light1', new BABYLON.Vector3(0.5, -1, 0.5), scene);\n            light1.position = new BABYLON.Vector3(0, 10, 0);\n            light1.intensity = 0.5;\n            const light2 = new BABYLON.HemisphericLight('light2', new BABYLON.Vector3(0.5, 1, 0), scene);\n            light2.intensity = 0.2;\n            const light3 = new BABYLON.HemisphericLight('light3', new BABYLON.Vector3(0.5, -1, 0.5), scene);\n            light3.intensity = 0.3;\n        }\n        let sphere1: BABYLON.Mesh;\n        let sphere2: BABYLON.Mesh;\n        let cylinder1: BABYLON.Mesh;\n        let cylinder2: BABYLON.Mesh;\n        let point1: BABYLON.AbstractMesh;\n        let point2: BABYLON.AbstractMesh;\n        { // pendulum\n            sphere1 = BABYLON.Mesh.CreateSphere('sphere1', 8, 1, scene);\n            sphere1.position.x = -0.5;\n            sphere1.position.y = 1;\n            sphere2 = BABYLON.Mesh.CreateSphere('sphere2', 8, 1, scene);\n            sphere2.position.x = 0.5;\n            sphere2.position.y = 1;\n            cylinder1 = BABYLON.MeshBuilder.CreateCylinder('cylinder1', {\n                diameterTop: 0.03,\n                diameterBottom: 0.03,\n                height: 2,\n                subdivisions: 8,\n            }, scene);\n            cylinder1.position.x = -0.5;\n            cylinder1.position.y = 2.5;\n            sphere1.addChild(cylinder1);\n            cylinder2 = BABYLON.MeshBuilder.CreateCylinder('cylinder2', {\n                diameterTop: 0.03,\n                diameterBottom: 0.03,\n                height: 2,\n                subdivisions: 8,\n            }, scene);\n            cylinder2.position.x = 0.5;\n            cylinder2.position.y = 2.5;\n            sphere2.addChild(cylinder2);\n            point1 = new BABYLON.AbstractMesh('point1', scene);\n            point1.position.x = -0.5;\n            point1.position.y = 3.5;\n            point2 = new BABYLON.AbstractMesh('point2', scene);\n            point2.position.x = 0.5;\n            point2.position.y = 3.5;\n        }\n        { // shadow\n            const shadowGenerator = new BABYLON.ShadowGenerator(512, light1);\n            // shadowGenerator.usePoissonSampling = true;\n            shadowGenerator.useBlurExponentialShadowMap = true;\n            shadowGenerator.getShadowMap()!.renderList!.push(\n                sphere1,\n                sphere2,\n                cylinder1,\n                cylinder2,\n            );\n        }\n        let ground: BABYLON.Mesh;\n        { // ground\n            ground = BABYLON.Mesh.CreateGround('ground', 6, 6, 2, scene);\n            ground.receiveShadows = true;\n        }\n        { // physics\n            const gravity = new BABYLON.Vector3(0,-9.8, 0);\n            const physics = new BABYLON.CannonJSPlugin();\n            scene.enablePhysics(gravity, physics);\n            ground.physicsImpostor = new BABYLON.PhysicsImpostor(\n                ground,\n                BABYLON.PhysicsImpostor.BoxImpostor,\n                { mass: 0, restitution: 0.5, disableBidirectionalTransformation: true },\n                scene,\n            );\n            sphere1.physicsImpostor = new BABYLON.PhysicsImpostor(\n                sphere1,\n                BABYLON.PhysicsImpostor.SphereImpostor,\n                { mass: 1, restitution: 0.95, disableBidirectionalTransformation: true },\n                scene,\n            );\n            sphere2.physicsImpostor = new BABYLON.PhysicsImpostor(\n                sphere2,\n                BABYLON.PhysicsImpostor.SphereImpostor,\n                { mass: 1, restitution: 0.95, disableBidirectionalTransformation: true },\n                scene,\n            );\n            point1.physicsImpostor = new BABYLON.PhysicsImpostor(\n                point1,\n                BABYLON.PhysicsImpostor.ParticleImpostor,\n                { mass: 0, disableBidirectionalTransformation: true },\n                scene,\n            );\n            point1.physicsImpostor.addJoint(\n                sphere1.physicsImpostor,\n                new BABYLON.PhysicsJoint(\n                    BABYLON.PhysicsJoint.Hinge2Joint,\n                    {\n                        connectedPivot: new BABYLON.Vector3(0, 2.5, 0),\n                        connectedAxis: new BABYLON.Vector3(0, 0, 0),\n                        collision: false,\n                    },\n                ),\n            );\n            point2.physicsImpostor = new BABYLON.PhysicsImpostor(\n                point2,\n                BABYLON.PhysicsImpostor.ParticleImpostor,\n                { mass: 0 },\n                scene,\n            );\n            point2.physicsImpostor.addJoint(\n                sphere2.physicsImpostor,\n                new BABYLON.PhysicsJoint(\n                    BABYLON.PhysicsJoint.Hinge2Joint,\n                    {\n                        connectedPivot: new BABYLON.Vector3(0, 2.5, 0),\n                        connectedAxis: new BABYLON.Vector3(0, 0, 0),\n                        collision: false,\n                    },\n                ),\n            );\n            sphere1.physicsImpostor.applyImpulse(\n                new BABYLON.Vector3(-7, 0, 0),\n                sphere1.getAbsolutePosition(),\n            );\n        }\n        engine.runRenderLoop(() => scene.render());\n    }}/>\n</Layout>;\n\nexport default PendulumPage;\n","import * as React from 'react';\nimport Helmet from 'react-helmet';\n\nimport './index.module.scss';\n\nconst Layout: React.SFC = ({ children }) => <>\n    <Helmet>\n        <title>babylon-practice</title>\n    </Helmet>\n    { children }\n</>;\n\nexport default Layout;\n","import * as React from 'react';\r\nimport {\r\n    Engine,\r\n    Scene,\r\n} from 'babylonjs';\r\n\r\ninterface BabylonCanvasProps {\r\n    className?: string;\r\n    init: (engine: Engine, scene: Scene, canvas: HTMLCanvasElement) => void;\r\n    engineOptions?: BABYLON.EngineOptions;\r\n    adaptToDeviceRatio?: boolean;\r\n    width?: number;\r\n    height?: number;\r\n}\r\ninterface BabylonCanvasState {\r\n    width: number;\r\n    height: number;\r\n}\r\nexport default class BabylonCanvas extends React.Component<BabylonCanvasProps, BabylonCanvasState> {\r\n    private scene: Scene | null = null;\r\n    private engine: Engine | null = null;\r\n    private canvas: React.RefObject<HTMLCanvasElement> = React.createRef();\r\n    state: BabylonCanvasState = { width: 0, height: 0 };\r\n    private setCanvasSize() {\r\n        this.setState({\r\n            width: this.props.width || window.innerWidth,\r\n            height: this.props.height || window.innerHeight,\r\n        });\r\n    }\r\n    private onResize = () => this.setCanvasSize();\r\n    componentDidUpdate(prevProps: BabylonCanvasProps) {\r\n        if ((prevProps.width !== this.props.width) || (prevProps.height !== this.props.height)) this.setCanvasSize();\r\n        this.engine && this.engine.resize();\r\n    }\r\n    componentDidMount() {\r\n        const {\r\n            init,\r\n            engineOptions,\r\n            adaptToDeviceRatio,\r\n        } = this.props;\r\n        const canvas = this.canvas.current!;\r\n        this.engine = new Engine(canvas, true, engineOptions, adaptToDeviceRatio);\r\n        this.scene = new Scene(this.engine);\r\n        init && init(this.engine, this.scene, canvas);\r\n        this.setCanvasSize();\r\n        window.addEventListener('resize', this.onResize);\r\n    }\r\n    componentWillUnmount() {\r\n        window.removeEventListener('resize', this.onResize);\r\n    }\r\n    render() {\r\n        const {\r\n            className,\r\n        } = this.props;\r\n        const {\r\n            width,\r\n            height,\r\n        } = this.state;\r\n        return <canvas\r\n            className={className}\r\n            width={width}\r\n            height={height}\r\n            ref={this.canvas}\r\n        />;\r\n    }\r\n}\r\n"],"sourceRoot":""}