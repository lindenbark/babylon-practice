{"version":3,"sources":["webpack:///./src/pages/scenes/pendulum/index.tsx","webpack:///./src/components/Layout/index.tsx","webpack:///./src/components/BabylonCanvas/index.tsx"],"names":["__webpack_exports__","default","react__WEBPACK_IMPORTED_MODULE_0__","createElement","_components__WEBPACK_IMPORTED_MODULE_1__","b","a","init","engine","scene","canvas","light1","sphere1","sphere2","cylinder1","cylinder2","point1","point2","camera","BABYLON","FreeCamera","Vector3","setTarget","Zero","attachControl","DirectionalLight","position","intensity","HemisphericLight","Mesh","CreateSphere","x","y","MeshBuilder","CreateCylinder","diameterTop","diameterBottom","height","subdivisions","addChild","AbstractMesh","ground","shadowGenerator","ShadowGenerator","useBlurExponentialShadowMap","getShadowMap","renderList","push","CreateGround","receiveShadows","gravity","physics","CannonJSPlugin","enablePhysics","physicsImpostor","PhysicsImpostor","BoxImpostor","mass","restitution","disableBidirectionalTransformation","SphereImpostor","ParticleImpostor","addJoint","PhysicsJoint","Hinge2Joint","connectedPivot","connectedAxis","collision","applyImpulse","getAbsolutePosition","runRenderLoop","render","_ref","children","Fragment","react_helmet__WEBPACK_IMPORTED_MODULE_1___default","BabylonCanvas_BabylonCanvas","t","react","createRef","state","width","onResize","_this","setCanvasSize","this","setState","props","window","innerWidth","innerHeight","componentDidUpdate","prevProps","resize","componentDidMount","_this$props","engineOptions","adaptToDeviceRatio","current","babylon","Engine","Scene","addEventListener","componentWillUnmount","removeEventListener","className","_this$state","ref","Component","c","i","d"],"mappings":"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","file":"component---src-pages-scenes-pendulum-index-tsx-03eff43a62b13c65bd2a.js","sourcesContent":["import * as React from 'react';\r\nimport {\r\n    Layout,\r\n    BabylonCanvas,\r\n} from '../../../components';\r\n\r\nconst PendulumPage = () => <Layout>\r\n    <BabylonCanvas init={(engine, scene, canvas) => {\r\n        { // camera\r\n            const camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 10, -10), scene);\r\n            camera.setTarget(BABYLON.Vector3.Zero());\r\n            camera.attachControl(canvas, true);\r\n        }\r\n        let light1: BABYLON.DirectionalLight;\r\n        { // light\r\n            light1 = new BABYLON.DirectionalLight('light1', new BABYLON.Vector3(0.5, -1, 0.5), scene);\r\n            light1.position = new BABYLON.Vector3(0, 10, 0);\r\n            light1.intensity = 0.5;\r\n            const light2 = new BABYLON.HemisphericLight('light2', new BABYLON.Vector3(0.5, 1, 0), scene);\r\n            light2.intensity = 0.2;\r\n            const light3 = new BABYLON.HemisphericLight('light3', new BABYLON.Vector3(0.5, -1, 0.5), scene);\r\n            light3.intensity = 0.3;\r\n        }\r\n        let sphere1: BABYLON.Mesh;\r\n        let sphere2: BABYLON.Mesh;\r\n        let cylinder1: BABYLON.Mesh;\r\n        let cylinder2: BABYLON.Mesh;\r\n        let point1: BABYLON.AbstractMesh;\r\n        let point2: BABYLON.AbstractMesh;\r\n        { // pendulum\r\n            sphere1 = BABYLON.Mesh.CreateSphere('sphere1', 8, 1, scene);\r\n            sphere1.position.x = -0.5;\r\n            sphere1.position.y = 1;\r\n            sphere2 = BABYLON.Mesh.CreateSphere('sphere2', 8, 1, scene);\r\n            sphere2.position.x = 0.5;\r\n            sphere2.position.y = 1;\r\n            cylinder1 = BABYLON.MeshBuilder.CreateCylinder('cylinder1', {\r\n                diameterTop: 0.03,\r\n                diameterBottom: 0.03,\r\n                height: 2,\r\n                subdivisions: 8,\r\n            }, scene);\r\n            cylinder1.position.x = -0.5;\r\n            cylinder1.position.y = 2.5;\r\n            sphere1.addChild(cylinder1);\r\n            cylinder2 = BABYLON.MeshBuilder.CreateCylinder('cylinder2', {\r\n                diameterTop: 0.03,\r\n                diameterBottom: 0.03,\r\n                height: 2,\r\n                subdivisions: 8,\r\n            }, scene);\r\n            cylinder2.position.x = 0.5;\r\n            cylinder2.position.y = 2.5;\r\n            sphere2.addChild(cylinder2);\r\n            point1 = new BABYLON.AbstractMesh('point1', scene);\r\n            point1.position.x = -0.5;\r\n            point1.position.y = 3.5;\r\n            point2 = new BABYLON.AbstractMesh('point2', scene);\r\n            point2.position.x = 0.5;\r\n            point2.position.y = 3.5;\r\n        }\r\n        { // shadow\r\n            const shadowGenerator = new BABYLON.ShadowGenerator(512, light1);\r\n            // shadowGenerator.usePoissonSampling = true;\r\n            shadowGenerator.useBlurExponentialShadowMap = true;\r\n            shadowGenerator.getShadowMap()!.renderList.push(\r\n                sphere1,\r\n                sphere2,\r\n                cylinder1,\r\n                cylinder2,\r\n            );\r\n        }\r\n        let ground: BABYLON.Mesh;\r\n        { // ground\r\n            ground = BABYLON.Mesh.CreateGround('ground', 6, 6, 2, scene);\r\n            ground.receiveShadows = true;\r\n        }\r\n        { // physics\r\n            const gravity = new BABYLON.Vector3(0,-9.8, 0);\r\n            const physics = new BABYLON.CannonJSPlugin();\r\n            scene.enablePhysics(gravity, physics);\r\n            ground.physicsImpostor = new BABYLON.PhysicsImpostor(\r\n                ground,\r\n                BABYLON.PhysicsImpostor.BoxImpostor,\r\n                { mass: 0, restitution: 0.5, disableBidirectionalTransformation: true },\r\n                scene,\r\n            );\r\n            sphere1.physicsImpostor = new BABYLON.PhysicsImpostor(\r\n                sphere1,\r\n                BABYLON.PhysicsImpostor.SphereImpostor,\r\n                { mass: 1, restitution: 0.95, disableBidirectionalTransformation: true },\r\n                scene,\r\n            );\r\n            sphere2.physicsImpostor = new BABYLON.PhysicsImpostor(\r\n                sphere2,\r\n                BABYLON.PhysicsImpostor.SphereImpostor,\r\n                { mass: 1, restitution: 0.95, disableBidirectionalTransformation: true },\r\n                scene,\r\n            );\r\n            point1.physicsImpostor = new BABYLON.PhysicsImpostor(\r\n                point1,\r\n                BABYLON.PhysicsImpostor.ParticleImpostor,\r\n                { mass: 0, disableBidirectionalTransformation: true },\r\n                scene,\r\n            );\r\n            point1.physicsImpostor.addJoint(\r\n                sphere1.physicsImpostor,\r\n                new BABYLON.PhysicsJoint(\r\n                    BABYLON.PhysicsJoint.Hinge2Joint,\r\n                    {\r\n                        connectedPivot: new BABYLON.Vector3(0, 2.5, 0),\r\n                        connectedAxis: new BABYLON.Vector3(0, 0, 0),\r\n                        collision: false,\r\n                    },\r\n                ),\r\n            );\r\n            point2.physicsImpostor = new BABYLON.PhysicsImpostor(\r\n                point2,\r\n                BABYLON.PhysicsImpostor.ParticleImpostor,\r\n                { mass: 0 },\r\n                scene,\r\n            );\r\n            point2.physicsImpostor.addJoint(\r\n                sphere2.physicsImpostor,\r\n                new BABYLON.PhysicsJoint(\r\n                    BABYLON.PhysicsJoint.Hinge2Joint,\r\n                    {\r\n                        connectedPivot: new BABYLON.Vector3(0, 2.5, 0),\r\n                        connectedAxis: new BABYLON.Vector3(0, 0, 0),\r\n                        collision: false,\r\n                    },\r\n                ),\r\n            );\r\n            sphere1.physicsImpostor.applyImpulse(\r\n                new BABYLON.Vector3(-7, 0, 0),\r\n                sphere1.getAbsolutePosition(),\r\n            );\r\n        }\r\n        engine.runRenderLoop(() => scene.render());\r\n    }}/>\r\n</Layout>;\r\n\r\nexport default PendulumPage;\r\n","import * as React from 'react';\nimport Helmet from 'react-helmet';\n\nimport './index.module.scss';\n\nconst Layout: React.SFC = ({ children }) => <>\n    <Helmet>\n        <title>babylon-practice</title>\n    </Helmet>\n    { children }\n</>;\n\nexport default Layout;\n","import * as React from 'react';\r\nimport {\r\n    Engine,\r\n    Scene,\r\n} from 'babylonjs';\r\n\r\ninterface BabylonCanvasProps {\r\n    className?: string;\r\n    init: (engine: Engine, scene: Scene, canvas: HTMLCanvasElement) => void;\r\n    engineOptions?: BABYLON.EngineOptions;\r\n    adaptToDeviceRatio?: boolean;\r\n    width?: number;\r\n    height?: number;\r\n}\r\ninterface BabylonCanvasState {\r\n    width: number;\r\n    height: number;\r\n}\r\nexport default class BabylonCanvas extends React.Component<BabylonCanvasProps, BabylonCanvasState> {\r\n    private scene: Scene | null = null;\r\n    private engine: Engine | null = null;\r\n    private canvas: React.RefObject<HTMLCanvasElement> = React.createRef();\r\n    state: BabylonCanvasState = { width: 0, height: 0 };\r\n    private setCanvasSize() {\r\n        this.setState({\r\n            width: this.props.width || window.innerWidth,\r\n            height: this.props.height || window.innerHeight,\r\n        });\r\n    }\r\n    private onResize = () => this.setCanvasSize();\r\n    componentDidUpdate(prevProps: BabylonCanvasProps) {\r\n        if ((prevProps.width !== this.props.width) || (prevProps.height !== this.props.height)) this.setCanvasSize();\r\n        this.engine && this.engine.resize();\r\n    }\r\n    componentDidMount() {\r\n        const {\r\n            init,\r\n            engineOptions,\r\n            adaptToDeviceRatio,\r\n        } = this.props;\r\n        const canvas = this.canvas.current!;\r\n        this.engine = new Engine(canvas, true, engineOptions, adaptToDeviceRatio);\r\n        this.scene = new Scene(this.engine);\r\n        init && init(this.engine, this.scene, canvas);\r\n        this.setCanvasSize();\r\n        window.addEventListener('resize', this.onResize);\r\n    }\r\n    componentWillUnmount() {\r\n        window.removeEventListener('resize', this.onResize);\r\n    }\r\n    render() {\r\n        const {\r\n            className,\r\n        } = this.props;\r\n        const {\r\n            width,\r\n            height,\r\n        } = this.state;\r\n        return <canvas\r\n            className={className}\r\n            width={width}\r\n            height={height}\r\n            ref={this.canvas}\r\n        />;\r\n    }\r\n}\r\n"],"sourceRoot":""}